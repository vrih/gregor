<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>gregor.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Gregor</span> <span class="project-version">0.3.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="gregor.core.html"><div class="inner"><span>gregor.core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="gregor.core.html#var-assign.21"><div class="inner"><span>assign!</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-assignment"><div class="inner"><span>assignment</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-close"><div class="inner"><span>close</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-commit-offsets.21"><div class="inner"><span>commit-offsets!</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-commit-offsets-async.21"><div class="inner"><span>commit-offsets-async!</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-committed"><div class="inner"><span>committed</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-consumer"><div class="inner"><span>consumer</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-consumer-record-.3Emap"><div class="inner"><span>consumer-record-&gt;map</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-flush"><div class="inner"><span>flush</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-offset-and-metadata"><div class="inner"><span>offset-and-metadata</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-pause"><div class="inner"><span>pause</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-poll"><div class="inner"><span>poll</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-position"><div class="inner"><span>position</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-producer"><div class="inner"><span>producer</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-records"><div class="inner"><span>records</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-resume"><div class="inner"><span>resume</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-seek.21"><div class="inner"><span>seek!</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-seek-to.21"><div class="inner"><span>seek-to!</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-send"><div class="inner"><span>send</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-subscribe"><div class="inner"><span>subscribe</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-subscription"><div class="inner"><span>subscription</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-topic-partition"><div class="inner"><span>topic-partition</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-unsubscribe"><div class="inner"><span>unsubscribe</span></div></a></li><li class="depth-1"><a href="gregor.core.html#var-wakeup"><div class="inner"><span>wakeup</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">gregor.core</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-assign.21"><h3>assign!</h3><div class="usage"><code>(assign! consumer topic partition &amp; tps)</code></div><div class="doc"><pre class="plaintext">Manually assign topic-partition pairs to this consumer.
</pre></div></div><div class="public anchor" id="var-assignment"><h3>assignment</h3><div class="usage"><code>(assignment consumer)</code></div><div class="doc"><pre class="plaintext">Get the set of partitions currently assigned to this consumer.
</pre></div></div><div class="public anchor" id="var-close"><h3>close</h3><div class="usage"><code>(close closable)</code></div><div class="doc"><pre class="plaintext">Close the consumer or producer, waiting indefinitely for any needed cleanup.
</pre></div></div><div class="public anchor" id="var-commit-offsets.21"><h3>commit-offsets!</h3><div class="usage"><code>(commit-offsets! consumer)</code><code>(commit-offsets! consumer offsets)</code></div><div class="doc"><pre class="plaintext">Commit offsets returned by the last poll for all subscribed topics and partitions.

offsets (optional) - commit a map of offsets by partition with associated metadata.
e.g. {(topic-partition 'my-topic' 1) (offset-and-metadata 1)
      (topic-partition 'other-topic' 2) (offset-and-metadata 67 'so metadata')}
</pre></div></div><div class="public anchor" id="var-commit-offsets-async.21"><h3>commit-offsets-async!</h3><div class="usage"><code>(commit-offsets-async! consumer)</code><code>(commit-offsets-async! consumer callback)</code><code>(commit-offsets-async! consumer offsets callback)</code></div><div class="doc"><pre class="plaintext">Commit offsets returned by the last poll for all subscribed topics and partitions,
or manually specify offsets to commit.

This is an asynchronous call and will not block. Any errors encountered are either
passed to the callback (if provided) or discarded.

offsets (optional) - commit a map of offsets by partition with associate metadata.
e.g. {(topic-partition 'my-topic' 1) (offset-and-metadata 1)
      (topic-partition 'other-topic' 2) (offset-and-metadata 67 'such meta')}

The committed offset should be the next message your application will consume,
i.e. lastProcessedMessageOffset + 1.

This map will be copied internally, so it is safe to mutate the map after returning.</pre></div></div><div class="public anchor" id="var-committed"><h3>committed</h3><div class="usage"><code>(committed consumer topic partition)</code></div><div class="doc"><pre class="plaintext">Return OffsetAndMetadata of the last committed offset for the given partition. This
offset will be used as the position for the consumer in the event of a failure.</pre></div></div><div class="public anchor" id="var-consumer"><h3>consumer</h3><div class="usage"><code>(consumer servers group-id &amp; [topics config])</code></div><div class="doc"><pre class="plaintext">Return a KafkaConsumer.

Args:
  servers: comma-separated host:port strs or list of strs as bootstrap servers
  group-id: str that identifies the consumer group this consumer belongs to
  topics: an optional list of topics to which the consumer will be dynamically
          subscribed.
  config: an optional map of str to str containing additional consumer
          configuration. More info on optional config is available here:
          <a href="http://kafka.apache.org/documentation.html#newconsumerconfigs">http://kafka.apache.org/documentation.html#newconsumerconfigs</a>

The StringDeserializer class is the default for both key.deserializer and
value.deserializer.
</pre></div></div><div class="public anchor" id="var-consumer-record-.3Emap"><h3>consumer-record-&gt;map</h3><div class="usage"><code>(consumer-record-&gt;map record)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-flush"><h3>flush</h3><div class="usage"><code>(flush producer)</code></div><div class="doc"><pre class="plaintext">Invoking this method makes all buffered records immediately available to send (even if
linger.ms is greater than 0) and blocks on the completion of the requests associated
with these records.</pre></div></div><div class="public anchor" id="var-offset-and-metadata"><h3>offset-and-metadata</h3><div class="usage"><code>(offset-and-metadata offset)</code><code>(offset-and-metadata offset metadata)</code></div><div class="doc"><pre class="plaintext">Metadata for when an offset is committed.
</pre></div></div><div class="public anchor" id="var-pause"><h3>pause</h3><div class="usage"><code>(pause consumer topic partition &amp; tps)</code></div><div class="doc"><pre class="plaintext">Suspend fetching for a seq of topic name, partition number pairs.
</pre></div></div><div class="public anchor" id="var-poll"><h3>poll</h3><div class="usage"><code>(poll consumer)</code><code>(poll consumer timeout)</code></div><div class="doc"><pre class="plaintext">Return a seq of consumer records currently available to the consumer (via a single poll).
Fetches sequetially from the last consumed offset.

A consumer record is represented as a clojure map with corresponding keys :value, :key,
:partition, :topic, :offset

timeout - the time, in milliseconds, spent waiting in poll if data is not
available. If 0, returns immediately with any records that are available now.
Must not be negative.</pre></div></div><div class="public anchor" id="var-position"><h3>position</h3><div class="usage"><code>(position consumer topic partition)</code></div><div class="doc"><pre class="plaintext">Return the offset of the next record that will be fetched (if a record with that
offset exists).</pre></div></div><div class="public anchor" id="var-producer"><h3>producer</h3><div class="usage"><code>(producer servers &amp; [config])</code></div><div class="doc"><pre class="plaintext">Return a KafkaProducer.

The producer is thread safe and sharing a single producer instance across
threads will generally be faster than having multiple instances.

Args:
  servers: comma-separated host:port strs or list of strs as bootstrap servers
  config: an optional map of str to str containing additional producer
          configuration. More info on optional config is available here:
          <a href="http://kafka.apache.org/documentation.html#newconsumerconfigs">http://kafka.apache.org/documentation.html#newconsumerconfigs</a>

The StringSerializer class is the default for both key.serializer and value.serializer

More info on settings is available here:
<a href="http://kafka.apache.org/081/documentation.html#producerconfigs">http://kafka.apache.org/081/documentation.html#producerconfigs</a></pre></div></div><div class="public anchor" id="var-records"><h3>records</h3><div class="usage"><code>(records consumer)</code><code>(records consumer timeout)</code></div><div class="doc"><pre class="plaintext">Return a lazy sequence of sequences of consumer-records by polling the consumer.

Each element in the returned sequence is the seq of consumer records returned from a
poll by the consumer. The consumer fetches sequetially from the last consumed offset.

A consumer record is represented as a clojure map with corresponding keys :value, :key,
:partition, :topic, :offset

timeout - the time, in milliseconds, spent waiting in poll if data is not
available. If 0, returns immediately with any records that are available now.
Must not be negative.</pre></div></div><div class="public anchor" id="var-resume"><h3>resume</h3><div class="usage"><code>(resume consumer topic partition &amp; tps)</code></div><div class="doc"><pre class="plaintext">Resume specified partitions which have been paused.
</pre></div></div><div class="public anchor" id="var-seek.21"><h3>seek!</h3><div class="usage"><code>(seek! consumer topic partition offset)</code></div><div class="doc"><pre class="plaintext">Overrides the fetch offsets that the consumer will use on the next poll.
</pre></div></div><div class="public anchor" id="var-seek-to.21"><h3>seek-to!</h3><div class="usage"><code>(seek-to! consumer destination topic partition &amp; tps)</code></div><div class="doc"><pre class="plaintext">Seek to the :beginning or :end offset for each of the given partitions.
</pre></div></div><div class="public anchor" id="var-send"><h3>send</h3><div class="usage"><code>(send producer topic value &amp; [callback])</code></div><div class="doc"><pre class="plaintext">Asynchronously send a record to a topic, return a java.util.concurrent.Future
</pre></div></div><div class="public anchor" id="var-subscribe"><h3>subscribe</h3><div class="usage"><code>(subscribe consumer topics-or-regex &amp; [partitions-assigned-fn partitions-revoked-fn])</code></div><div class="doc"><pre class="plaintext">Subscribe to the given list of topics to get dynamically assigned partitions. Topic
subscriptions are not incremental. This list will replace the current assignment (if
there is one). It is not possible to combine topic subscription with group management
with manual partition assignment through assign(List). If the given list of topics is
empty, it is treated the same as unsubscribe.

topics-or-regex can be a list of topic names or a java.util.regex.Pattern object to
subscribe to all topics matching a specified pattern.

the optional functions are a callback interface to trigger custom actions when the set
of partitions assigned to the consumer changes.
</pre></div></div><div class="public anchor" id="var-subscription"><h3>subscription</h3><div class="usage"><code>(subscription consumer)</code></div><div class="doc"><pre class="plaintext">Get the current subscription for this consumer.
</pre></div></div><div class="public anchor" id="var-topic-partition"><h3>topic-partition</h3><div class="usage"><code>(topic-partition topic partition)</code></div><div class="doc"><pre class="plaintext">A topic name and partition number.
</pre></div></div><div class="public anchor" id="var-unsubscribe"><h3>unsubscribe</h3><div class="usage"><code>(unsubscribe consumer)</code></div><div class="doc"><pre class="plaintext">Unsubscribe from topics currently subscribed with subscribe. This also clears any
partitions directly assigned through assign.</pre></div></div><div class="public anchor" id="var-wakeup"><h3>wakeup</h3><div class="usage"><code>(wakeup consumer)</code></div><div class="doc"><pre class="plaintext">Wakeup the consumer. This method is thread-safe and is useful in particular to abort a
long poll. The thread which is blocking in an operation will throw WakeupException.</pre></div></div></div></body></html>